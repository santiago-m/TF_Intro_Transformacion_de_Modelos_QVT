/*
 * The SimpleUML to RDB Sample demonstrates how to use QVT transformations for 
 * transforming platform independent model to platform specific model. 
 * 
 * It also demonstrates the following basic features of QVT language: 
 * helper queries, mapping guards, and resolution operations.
 * 
 * Sample model pim.simpleuml is included to be used as an input for the transformation.
 */

/*
 * Two modeltypes are declared. The http NS URIs correspond to those used to register the 
 * Ecore models in the environment. Alternatively, a workspace metamodel may be used 
 * in conjunction with mappings defined in the project properties.
 */
// modeltype UML uses 'SimpleUML';
 
 //modeltype RDB uses 'SimpleRDBMS';
 
 
 modeltype ERM uses 'ERModel';
 modeltype RDB uses 'SimpleRDBMS';

/*
 * The transformation signature declares that a UML modeltype is required as input, while an RDB
 * modeltype is produced as an output.  The UML modeltype is referenced as 'uml' throughout the 
 * transformation definition, while no name is needed for the output RDB modeltype.  Note that OCL 
 * type and namespace notation are used in operational QVT (: and :: respectively).
 */
transformation ERModel_To_SimpleRdb(in erm : ERM, out RDB);

/*
 * The main entry point of the transformation.  The 'uml' reference to the input UML modeltype 
 * instance is used to collect all rootObjects() of type Model.  The rootObjects() operation 
 * is available on all QVT Model objects (extents) and returns those objects found at the 
 * root of the input model.  The [UML::Model] statement following the call to rootObjects() 
 * is shorthand notation for the imperative select (xselect) construct where the condition is 
 * a type expression, which effectively performs a oclIsKindOf(UML::Model) with type recasting 
 * as a sequence.
 *
 * The invocation of the model2RDBModel() mapping is done using an -> operator, which is a 
 * shorthand notation for the imperative collect (xcollect) construct.  Alternatively, it could
 * be written as uml.rootObjects()[UML::Model]->xcollect(a | a.map model2RDBModel());
 */
main() {
	erm.objectsOfType(ERM::Package) -> map packageToSchema(); 
}

/*
 * This mapping creates an RDB Schema object from a UML Package.  It includes a when clause to 
 * verify the passed Package contains persistent classes.  Look below to see the logic employed
 * within the hasPersistentClasses() query.
 *
 * The name attributes map directly, while the elements reference is populated with RDB Table 
 * objects mapped from persistent UML Class objects using a map invocation and similar 
 * shorthand notation used above.
 */
mapping ERM::Package::packageToSchema() : RDB::Schema 
{
	name := self.name;
	kind := self.kind;
	tables := self.elements[ERM::Entity] 
					-> select(e : ERM::Entity | e.belongs_to_relation() or not (e.is_parent()))
					-> sortedBy(relationDependencies()) 
					-> map persistentEntityToTable() 
					-> union(
			  			self.elements[ERM::Relation] 
			  				-> select(r : ERM::Relation | r.is_n_to_n()) 
			  				-> map relation_n_to_n_ToTable()
			  		   );
} 

mapping ERM::Relation::relation_n_to_n_ToTable() : RDB::Table
{
	name := self.name;
	kind := self.kind;
	let t1 : RDB::Table = RDB::Table.allInstances() 
				-> select(t : RDB::Table | t.name = self.entity_1.name) 
				-> any(true), 
		t2 : RDB::Table = RDB::Table.allInstances() 
				-> select(t : RDB::Table | t.name = self.entity_2.name) 
				-> any(true)
		in do {
			keys := t1.map keyFromTables(t2);
			primary_key := keys 
								-> selectByKind(RDB::Primary_Key) 
								-> any(true);
			let foreign_columns : Sequence(RDB::Column) = t1.oclAsSet() 
								-> including(t2) 
								-> collect(t : RDB::Table | t.columns) 
								-> asSequence() 
								-> map create_derived_columns('') 
			in do {
				columns := self.attributes 
							-> map attributeToColumn() 
							-> sortedBy(name) 
							-> union(
								foreign_columns
							   );
				foreignKeys := t1.oclAsSet() 
							-> including(t2) 
							-> map foreignKeyFromTable(self.name, foreign_columns);
				if (primary_key = null) {
					let new_pk : RDB::Primary_Key = foreign_columns 
							-> map create_pkey_from_with_columns() 
					in do { 
						keys := keys 
								-> including(new_pk);
						primary_key := new_pk;
					};
				}
			}
		}
}

/*
 * This mapping produces an RDB Table object from a UML persistent Class object. The when clause
 * uses the isPersistent() query below to see if the Class has a 'persistent' string as one of 
 * its stereotype strings.
 *
 * Again, the name attributes map directly.  The Class is mapped to a set of TableColumn objects
 * using the class2columns() mapping, the results of which are sorted by name using the OCL 
 * sortedBy() operation.  The primaryKey is set using the class2primaryKey() mapping, while 
 * foreignKeys are set using a resolveIn function.  This will allow us to resolve RDB ForeignKey 
 * objects created using the relationshipAttribute2foreignKey() mapping for each of the Class 
 * attributes. 
 */
mapping ERM::Entity::persistentEntityToTable() : RDB::Table 
{
	name := self.name;
	keys := self.keys 
			-> excluding(self.primary_key) 
			-> map entityKeyToTableKey() 
			-> including( 
				self.primary_key.map entityPKToTablePK() 
				-> any(true).oclAsType(RDB::Primary_Key));
	primary_key := keys 
			-> select(k : RDB::Key | k.oclIsKindOf(RDB::Primary_Key)) 
			-> first().oclAsType(RDB::Primary_Key);
			
	let dependencie_tables : Set(RDB::Table) = RDB::Table.allInstances() 
			-> select(t : RDB::Table | self.dependsOn(t)) 
	in 
		let foreign_columns : Sequence(RDB::Column) = dependencie_tables 
			-> collect(t : RDB::Table | t.primary_key.columns) 
			-> asSequence() 
			-> map create_derived_columns(self.name) 
		in do {
			columns := self.attributes 
				-> map attributeToColumn() 
				-> sortedBy(name) 
				-> union(
					foreign_columns
				   );
			foreignKeys := dependencie_tables 
				-> map foreignKeyFromTable(self.name, foreign_columns);
			if (not self.parent.existTable(dependencie_tables)) {
				let derived_columns : Set(RDB::Column) = self.get_untabulated_parents_attributes() 
					-> derivedAttributeToColumn(self.name) 
				in do {
					columns := derived_columns
						-> asSet()
						-> union(
							columns);
					if (primary_key = null) {
						primary_key := derived_columns 
										-> select(c : RDB::Column | self.parent.primary_key.attribute_set 
														-> collect(a : ERM::Attribute | a.name)
												   		-> includes(c.name.substringBefore('_'+self.name))
												  ) -> map pk_from_derived_columns(self.name);
						primary_key.k_owner := primary_key.pk_owner;
					}
				}
			}
			else {
				if (primary_key = null) {
					let new_pk : RDB::Primary_Key = foreign_columns 
						-> map create_pkey_from_with_columns() 
					in do { 
						keys := keys 
							-> including(new_pk);
						primary_key := new_pk;
					};
				};
			}
		};
		schema := self.resolveoneIn(ERM::Package::packageToSchema,RDB::Schema);
}

mapping Set(RDB::Column)::pk_from_derived_columns(new_owner_name : String) : RDB::Primary_Key {
	name := 'pk_' + new_owner_name;
	kind := 'primary_key';
	columns := self;
}

mapping RDB::Column::create_derived_columns(owner_name : String) : RDB::Column {
	name := 'fk_' + self.name + '_' + owner_name;
	type := self.type;
}

mapping RDB::ForeignKey::fk_to_column() : RDB::Column {
	name := 'fk_' + self.columns->any(true).name + '__' + self.refersTo.k_owner.name;
}

mapping RDB::Table::keyFromTables(t : RDB::Table) : RDB::Primary_Key {
	columns := self.columns ->union(t.columns); 
}

mapping RDB::Table::foreignKeyFromTable(owner_name : String, cols : Sequence(RDB::Column)) : RDB::ForeignKey {
		name := 'fk_' + self.name + '_' + owner_name;
		columns := cols -> select(c : RDB::Column | c.owner.name = self.name);
		refersTo := self.primary_key;
}

mapping Sequence(RDB::Column)::create_pkey_from_with_columns() : RDB::Primary_Key {
	name := 'pk_'+self -> first().owner.name;
	columns := self;
}

/*
 * A PrimaryKey object is created from a Class by prefixing the name with 'PK' and resolving 
 * one (the first) Table created from the Class in order to obtain its primary key columns 
 * using a query.
 */
mapping ERM::Key::entityKeyToTableKey() : RDB::Key {
		columns := self.attribute_set -> map attributeToColumn();
}

mapping ERM::Primary_Key::entityPKToTablePK() : RDB::Primary_Key {
	name := 'pk_'+self.pk_owner.name;
	kind := 'primary_key';
	columns := self.attribute_set -> map attributeToColumn();
}

/*
 * This mapping will create an OrderedSet of RDB TableColumn objects from a UML Class object.
 * Similar to package2schemas(), this mapping has no population section, but just an init 
 * that assigns the result based on the union of type mappings from the Class and its
 * generalizations (Class extends DataType).
 *
 * Note that this mapping is defined for type UML::Class and also takes a UML::Class named 
 * targetClass as a parameter.  This pattern is used in several places within this
 * transformation definition to account for how generalization in the UML model is 
 * mapped to columns in the RDB model.  As properties and inherited properties are 
 * flattened into columns, the combined use of 'self' and 'target' parameter represent a
 * way to allow multiple copies of columns for a given property source, as subsequent
 * mapping invocations retrieve the same resulting columns from the trace model. 
 */
mapping ERM::Attribute::attributeToColumn() : RDB::Column {
	name := self.name;
	kind := self.kind;
	type := self.type.name;
}

mapping ERM::Attribute::derivedAttributeToColumn(new_owner_name : String) : RDB::Column {
	name := self.name + '_' + new_owner_name;
	kind := self.kind;
	type := self.type.name;
}

query ERM::Entity::get_untabulated_parents_attributes() : Set(ERM::Attribute) {
	if (self.parent.existTable(RDB::Table.allInstances())) then
		return null.oclAsSet()
	else
		return self.parent.attributes 
			-> union(
					self.parent.get_untabulated_parents_attributes()
				)
	endif
}

query ERM::Entity::is_parent() : Boolean {
	return ERM::Entity.allInstances() -> exists(e : ERM::Entity | e.parent = self);
}

query ERM::Entity::belongs_to_relation() : Boolean {
	return ERM::Relation.allInstances() -> exists(r : ERM::Relation | r.entity_1 = self or r.entity_2 = self);
}

query ERM::Entity::relationDependencies() : Integer {
	if (self.isIndependent()) {
		return 0;
	}
	else {
		return self.dependsOn() + (self.dependencies() -> map relationDependencies() ->sum() );
	}
}

query ERM::Entity::isIndependent() : Boolean {
	return not (ERM::Relation.allInstances() -> exists(r : ERM::Relation | (r.entity_1 = self and r.cardinality_1 = 'N' and r.cardinality_2 = '1') or
																	  (r.entity_2 = self and r.cardinality_2 = 'N' and r.cardinality_1 = '1') ))
				and self.parent = null;
}

query ERM::Entity::dependsOn() : Integer {
	return ERM::Relation.allInstances() -> select (r : ERM::Relation | (r.entity_1 = self and r.cardinality_1 = 'N' and r.cardinality_2 = '1') or
																	   (r.entity_2 = self and r.cardinality_2 = 'N' and r.cardinality_1 = '1')
												  ) -> size() + self.parent.oclAsSet() -> size();
}

query ERM::Entity::dependencies() : Set(Entity) {
	let allRelations : Set(ERM::Relation) = ERM::Relation.allInstances() in
		return allRelations -> select (r : ERM::Relation | (r.entity_1 = self and r.cardinality_1 = 'N' and r.cardinality_2 = '1')) -> collect(r : ERM::Relation | r.entity_2) 
						-> union(allRelations -> select (r : ERM::Relation | (r.entity_2 = self and r.cardinality_2 = 'N' and r.cardinality_1 = '1')) -> collect(r : ERM::Relation | r.entity_1)) -> asSet()
						-> union(self.parent.oclAsSet());
	return null;
}

query ERM::Entity::dependsOn(t : RDB::Table) : Boolean {
	return self.dependencies() -> collect(e : ERM::Entity | e.name) -> includes(t.name);
}

query ERM::Entity::canBeCreated() :Boolean {
	return not (ERM::Relation.allInstances() -> exists(r : ERM::Relation | (not r.is_n_to_n()) and ( 
																				(r.entity_1 = self and r.cardinality_1 = 'N') or
																				(r.entity_2 = self and r.cardinality_2 = 'N')
																			) ));
}

query ERM::Entity::belongsTo1ToXRelation() : Boolean {
	return ERM::Relation.allInstances() -> select(r : ERM::Relation | r.entity_1 = self or r.entity_2 = self and (not r.is_n_to_n())) -> notEmpty();
}

query ERM::Entity::existTable(tset : Set(RDB::Table)) : Boolean {
	return tset -> collect(t : RDB::Table | t.name) ->includes(self.name);
}

query ERM::Relation::is_n_to_n() : Boolean {
	return self.cardinality_1 = 'N' and self.cardinality_2 = 'N';
}

query ERM::Relation::is_1_to_1() : Boolean {
	return self.cardinality_1 = '1' and self.cardinality_2 = '1';
}

/*
 * This query returns true if the list of string stereotypes includes one
 * equal to 'persistent'.
 */
query ERM::ERMElement::isPersistent() : Boolean {
	return self.kind->includes('persistent')
}

/*
 * This query examines the contents of a Package to determine if there exists
 * at least one Class that returns true for the isPersistent() query.
 */
query ERM::Package::hasPersistentEntities() : Boolean {
	return self.elements->exists(
		let c : ERM::Entity = oclAsType(ERM::Entity) in 
			c.oclIsUndefined() implies c.isPersistent())
}

/*
 * This helper returns the RDB primitive string corresponding to the passed 
 * UML primitive string.  This helper produces no side effects and could be 
 * written as a query, alternatively.
 */
helper umlPrimitive2rdbPrimitive(in name : String) : String {
	return if name = 'String' then 'varchar' else
		if name = 'Boolean' then 'int' else
			if name = 'Integer' then 'int' else
				name
			endif
		endif
	endif
}
